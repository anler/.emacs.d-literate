* Table of contents                                                     :TOC:
 - [[#compose-functions][Compose functions]]
 - [[#create-circular-lists][Create circular lists]]
 - [[#comment-lines][Comment lines]]
 - [[#scroll-the-buffer][Scroll the buffer]]
 - [[#join-lines][Join lines]]
 - [[#kill-buffer-and-delete-its-file][Kill buffer and delete its file]]
 - [[#rename-buffer-and-its-file][Rename buffer and its file]]
 - [[#extend-eval-last-sexp-extended][Extend eval-last-sexp extended]]
 - [[#partial-functions][Partial functions]]
 - [[#create-scratch-buffers][Create scratch buffers]]
 - [[#duplicate-line][Duplicate line]]
 - [[#quit-other-window][Quit other window]]
 - [[#select-other-window-backward][Select other window backward]]

* Compose functions
Taken from [[http://nullprogram.com/blog/2010/11/15/][nullprogram]].
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun compose (&rest funs)
    "Return function composed of FUNS."
    (lexical-let ((lex-funs funs))
      (lambda (&rest args)
        (reduce 'funcall (butlast lex-funs)
                :from-end t
                :initial-value (apply (car (last lex-funs)) args)))))
#+END_SRC

* Create circular lists
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun make-circular-list (list)
    "Create a circular version of list."
    (setf (cdr (last list)) list)
    list)
#+END_SRC

* Comment lines
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun comment-or-uncomment ()
    "Comment or uncomment current line or region if there's a region active."
    (interactive)
    (let ((start (line-beginning-position))
          (end (line-end-position)))
      (when (region-active-p)
        (setq start (save-excursion
                      (goto-char (region-beginning))
                      (beginning-of-line)
                      (point))
              end (save-excursion
                    (goto-char (region-end))
                    (end-of-line)
                    (point))))
      (comment-or-uncomment-region start end)))
#+END_SRC

* Scroll the buffer
The exact same functionality VIM has for ~C-e~ and ~C-y~ in normal mode:
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun scroll-up-one-line-command ()
    "Scroll text of selected window upward 1 line."
    (interactive)
    (scroll-up-command 1)
    (next-line))

  (defun scroll-down-one-line-command ()
    "Scroll text of selected window downward 1 line."
    (interactive)
    (scroll-down-command 1)
    (previous-line))
#+END_SRC

* Join lines
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun join-line-below ()
    "Join line bellow current line."
    (interactive)
    (join-line -1))
#+END_SRC

* Kill buffer and delete its file
Modified version of one found in: [[http://tuxicity.se/emacs/elisp :tangle ~/.emacs.d/defuns.el/2010/11/16/delete-file-and-buffer-in-emacs.html][tuxicity]].
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun kill-buffer-and-file (buffer-name)
    "Removes file connected to current buffer and kills buffer."
    (interactive "bKill buffer and its file:")
    (let* ((buffer (get-buffer buffer-name))
           (filename (buffer-file-name buffer)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" buffer-name)
        (delete-file filename)
        (kill-buffer buffer))))
#+END_SRC

* Rename buffer and its file
Original command by Steve Yegge: [[[http://steve.yegge.googlepages.com/my-dot-emacs-file%0A][link]]].
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun rename-buffer-and-file (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name for buffer and file: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)))))
#+END_SRC

* Extend eval-last-sexp extended
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun ext/eval-last-sexp (arg)
    "Extension over eval-last-sexp that replaces the last sexp with the
  result if called with the universal argument twice."
    (interactive "P")
    (if (= 16 (prefix-numeric-value arg))
        (replace-last-sexp)
      (eval-last-sexp arg)))
#+END_SRC

#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun replace-last-sexp ()
    "Eval last sexp and replaces it in the buffer with its result."
    (interactive)
    (let ((result (eval (preceding-sexp))))
      (kill-sexp -1)
      (insert (format "%s" result))))
#+END_SRC

* Partial functions
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun partial (function &rest args)
    (lambda (&rest more-args)
      (apply function (append args more-args))))
#+END_SRC

* Create scratch buffers
Command for creating additional scratch buffers.
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun create-scratch-buffer (mode)
    "Create a brand new scratch buffer."
    (interactive "CMode: ")
    (cl-labels ((get-scratch-buffer-name (index)
                                (let ((name (format "*scratch<%s>*" index)))
                                  (if (null (get-buffer name))
                                      name
                                    (get-scratch-buffer-name (1+ index))))))
      (switch-to-buffer (get-buffer-create (get-scratch-buffer-name 1)))
      (call-interactively mode)))
#+END_SRC

* Duplicate line
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun duplicate-line ()
    "Duplicate the line below the cursor and move the cursor 
  to the duplicated line."
    (interactive)
    (kill-ring-save (line-beginning-position)
                    (line-end-position))
    (save-excursion
      (end-of-line)
      (open-line 1)
      (next-line 1)
      (yank))
    (next-line 1))
#+END_SRC

* Quit other window
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun quit-other-window ()
    "Send `quit-window' in the window returned by `other-window'"
    (interactive)
    (other-window 1)
    (quit-window))
#+END_SRC

* Select other window backward
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (defun other-window-backward (count)
    "Select another window in anti-cyclic ordering of windows.
  COUNT specifies the number of windows to skip, starting with the
  selected window, before making the selection."
    (interactive "P")
    (other-window (- (prefix-numeric-value count))))
  
  (global-set-key (kbd "C-x C-o") 'other-window-backward)
#+END_SRC

* Show which function
#+BEGIN_SRC elisp :tangle ~/.emacs.d/defuns.el
  (autoload 'which-function "which-func")

  (defun show-which-function ()
    "Show the function definition the cursor is in the echo area"
    (interactive)
    (message (which-function)))
#+END_SRC
